const mongoose = require("mongoose");
const Vulnerability = require("../models/Vulnerability");
const System = require("../models/System");
const { calculateSystemRisk } = require("../services/riskEngine");
const { emitEvent } = require("../socket/socket");

/* ======================================================
   Helper: Recalculate Risk
====================================================== */
const recalculateSystemRisk = async (system) => {
  const openVulns = await Vulnerability.find({
    system: system._id,
    status: "open",
    isActive: true,
  });

  const riskResult = calculateSystemRisk(
    openVulns,
    system.environment
  );

  system.riskScore = riskResult.riskScore;
  system.status = riskResult.status;
  system.lastScan = new Date();

  await system.save();

  return riskResult;
};

/* ======================================================
   Create Vulnerability
====================================================== */
exports.createVulnerability = async (req, res) => {
  const session = await mongoose.startSession();

  try {
    session.startTransaction();

    const {
      systemId,
      cveId,
      title,
      severity,
      cvssScore,
      exploitAvailable = false,
    } = req.body;

    if (!systemId || !severity || cvssScore == null) {
      await session.abortTransaction();
      return res.status(400).json({
        message: "Missing required fields",
      });
    }

    const system = await System.findOne({
      _id: systemId,
      owner: req.user._id,
      isActive: true,
    }).session(session);

    if (!system) {
      await session.abortTransaction();
      return res.status(404).json({
        message: "System not found",
      });
    }

    const [vulnerability] = await Vulnerability.create(
      [
        {
          system: systemId,
          cveId,
          title,
          severity,
          cvssScore,
          exploitAvailable,
        },
      ],
      { session }
    );

    const riskResult = await recalculateSystemRisk(system);

    await session.commitTransaction();

    /* ðŸ”¥ REAL-TIME EVENTS */
    emitEvent("vulnerability:created", {
      systemId,
      vulnerability,
    });

    emitEvent("risk:updated", {
      systemId,
      riskScore: riskResult.riskScore,
      status: riskResult.status,
    });

    return res.status(201).json({
      message: "Vulnerability created successfully",
      vulnerability,
      updatedSystem: system,
    });

  } catch (error) {
    await session.abortTransaction();
    return res.status(500).json({
      message: "Failed to create vulnerability",
      error: error.message,
    });
  } finally {
    session.endSession();
  }
};

/* ======================================================
   Get System Vulnerabilities
====================================================== */
exports.getSystemVulnerabilities = async (req, res) => {
  try {
    const { systemId } = req.params;

    const system = await System.findOne({
      _id: systemId,
      owner: req.user._id,
      isActive: true,
    });

    if (!system) {
      return res.status(404).json({
        message: "System not found",
      });
    }

    const vulnerabilities = await Vulnerability.find({
      system: systemId,
      isActive: true,
    }).sort({ createdAt: -1 });

    return res.status(200).json(vulnerabilities);

  } catch (error) {
    return res.status(500).json({
      message: "Failed to fetch vulnerabilities",
      error: error.message,
    });
  }
};

/* ======================================================
   Patch Vulnerability
====================================================== */
exports.patchVulnerability = async (req, res) => {
  const session = await mongoose.startSession();

  try {
    session.startTransaction();

    const vulnerability = await Vulnerability.findById(req.params.id)
      .session(session);

    if (!vulnerability) {
      await session.abortTransaction();
      return res.status(404).json({
        message: "Vulnerability not found",
      });
    }

    const system = await System.findOne({
      _id: vulnerability.system,
      owner: req.user._id,
      isActive: true,
    }).session(session);

    if (!system) {
      await session.abortTransaction();
      return res.status(403).json({
        message: "Unauthorized access",
      });
    }

    vulnerability.status = "patched";
    vulnerability.patchedAt = new Date();

    await vulnerability.save({ session });

    const riskResult = await recalculateSystemRisk(system);

    await session.commitTransaction();

    /* ðŸ”¥ REAL-TIME EVENTS */
    emitEvent("vulnerability:patched", {
      systemId: system._id,
      vulnerabilityId: vulnerability._id,
    });

    emitEvent("risk:updated", {
      systemId: system._id,
      riskScore: riskResult.riskScore,
      status: riskResult.status,
    });

    return res.status(200).json({
      message: "Vulnerability patched successfully",
      updatedSystem: system,
    });

  } catch (error) {
    await session.abortTransaction();
    return res.status(500).json({
      message: "Failed to patch vulnerability",
      error: error.message,
    });
  } finally {
    session.endSession();
  }
};